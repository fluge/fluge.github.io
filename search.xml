<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我理解的TCP协议(三)---滑动窗口以及拥塞控制</title>
      <link href="/2017/08/29/%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84TCP%E5%8D%8F%E8%AE%AE(%E4%B8%89)---%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%BB%A5%E5%8F%8A%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
      <url>/2017/08/29/%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84TCP%E5%8D%8F%E8%AE%AE(%E4%B8%89)---%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%BB%A5%E5%8F%8A%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> TCP/IP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我理解的TCP协议(一)---链接的建立和终止</title>
      <link href="/2017/03/06/%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84TCP%E5%8D%8F%E8%AE%AE(%E4%B8%80)---%E9%93%BE%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/"/>
      <url>/2017/03/06/%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84TCP%E5%8D%8F%E8%AE%AE(%E4%B8%80)---%E9%93%BE%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/</url>
      
        <content type="html"><![CDATA[<p>TCP是一个非常复杂的面向连接的协议,在很30多年来，各种优化变种争论和修改不断,所以我先从连接的建立和终止开始写TCP。后面应该还有几篇文章写TCP的另外几个特别重要的特性。<br>TCP最开始被我知道就先从很有特点的链接建立和终止—三次握手和四次挥手,基本上TCP协议的可靠性就是从保证连接的可靠性开始的。  </p><h3 id="TCP链接的建立—三次握手"><a href="#TCP链接的建立—三次握手" class="headerlink" title="TCP链接的建立—三次握手"></a>TCP链接的建立—三次握手</h3><p>对于三次握手，其实是TCP比较著名的东西了,在完全不了解这个TCP的时候就知道有这个东西了，但是开始的时候总有一点让我非常的疑惑:TCP为什么是三次握手,为什么不是两次或四次？  </p><h4 id="TCP-为什么是三次握手-为什么不是两次或四次？"><a href="#TCP-为什么是三次握手-为什么不是两次或四次？" class="headerlink" title="TCP 为什么是三次握手,为什么不是两次或四次？"></a>TCP 为什么是三次握手,为什么不是两次或四次？</h4><p>要解释这个问题,首先明白TCP出现的价值和思路:是<code>为了在不可靠的互联网络上提供一个可靠的端到端字节流而设计的</code>,<code>并且一个TCP连接是全双工</code>。这是TCP很重要的一个设计理念:提供了一种<code>可靠的</code>,<code>面向连接的</code>字节流运输层服务,并且是双全工的。这里需要理解双全工的意思：就是两端之间进行通信，这两端既可以是数据的接收方，也可以是数据的发送方。<br>1、 可靠模型:但是为了数据的安全送达，就必须在发送数据前向另一个端口进行通信</p><blockquote><p>数据发送端A:嘿,我想发送数据了,可以么。<br>数据接收端B:好的，这边允许接受。  </p></blockquote><p>然后数据的发送端就可以发送数据了,这里就基本保证你发的在接收方会正常的接受并不会发错。这是发送数据的<code>基本可靠模型</code>。<br>2、 连接模型:在TCP的要求中,需要一种面向连接的通信:<code>连接</code>在我理解中就是相当于有一根空水管,连接两个水池(为两个水池传输东西),在水管中传输东西的效率肯定会高于用桶去一桶桶的装,来的方便。<br><a id="more"></a><br>这两个模型联系起来:就是当两个水池之间要进行交换东西的时候,需要有一个水管去保持两边的交换的效率。这个时候就把水管的一边和一个水池相连(用水管的另一边进行可靠模型的验证)，如果验证通过在把另一边进行相连，然后再去用可靠模型验证。都通过就说明整个链接水管工作完成了。可以正常的工作。<br>在上面的水管是虚拟的不存在的，抽象出整个可靠模型，然后简化整个过程:A,B连个端口</p><blockquote><p>A:我想向你发送数据，可以么。<br>B:可以啊。（第一次可靠验证结束）<br>B:我想向你发送数据，可以么。<br>A:可以啊。 (第二次可靠验证结束)  </p></blockquote><p>然后上面的过程其实可以进一步的优化就是把两次的可靠验证结合在一起:中间两次的B的发送数据显然可以合并为一次数据发送。<br>上面就是我对为什么是三次握手,为什么不是两次或四次的理解的一个方向。两次握手只能让链接的一端发送的数据的是可信的，四次握手就显得有点多余。  </p><h4 id="TCP的三次握手具体过程"><a href="#TCP的三次握手具体过程" class="headerlink" title="TCP的三次握手具体过程"></a>TCP的三次握手具体过程</h4><p>TCP的三次握手除了要建立可靠的连接外还有就是初始化SYN(传输数据的包的序号)。也就下图中的<code>x</code>和<code>y</code>。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。<br><img src="http://ofa8x9gy9.bkt.clouddn.com/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt><br>基本过程:</p><ol><li>第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；</li><li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>在握手值得注意的是:</li><li>关于建连接时SYN超时。如果服务端接到了客户端发的SYN后回了ACK后client掉线了，服务器端没有收到客户端回来的ACK(第二次握手完成)，那么，这个连接处于一个中间状态，即没成功，也没失败。于是,服务器端如果在一定时间内没有收到的TCP会重发ACK。在Linux下，默认重试次数为5次,重试的间隔时间从1s开始每次都翻倍,5次的重试时间间隔为1s,2s,4s,8s,16s,总共31s,第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。</li><li>关于SYN Flood攻击。一些恶意的人就为此制造了SYN Flood攻击——给服务器发了一个SYN后，就下线了，于是服务器需要默认等63s才会断开连接，这样，攻击者就可以把服务器的syn连接的队列耗尽，让正常的连接请求不能处理。于是，Linux下给了一个叫tcp_syncookies参数来应对这个事——当SYN队列满了后,TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去(又叫cookie),如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来,然后服务端可以通过cookie建连接(即使你不在SYN队列中)。请注意,请先千万别用tcp_syncookies来处理正常的大负载的连接的情况。因为,synccookies是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择,第一个是:tcp_synack_retries可以用他来减少重试次数；第二个是:tcp_max_syn_backlog,可以增大SYN连接数;第三个是:tcp_abort_on_overflow处理不过来干脆就直接拒绝连接了。<h3 id="TCP链接的终止—四次挥手"><a href="#TCP链接的终止—四次挥手" class="headerlink" title="TCP链接的终止—四次挥手"></a>TCP链接的终止—四次挥手</h3>挥手过程就很好理解了，TCP是双全工的。发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。<blockquote><p>A：兄弟我的数据传送完了<br>B：收到了—-过了一会B的数据也传完了<br>B：兄弟我数据传完了<br>A：好的收到了   </p></blockquote></li></ol><p><img src="http://ofa8x9gy9.bkt.clouddn.com/TCP%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt><br>在里面需要注意的是:关于<code>MSL</code>和<code>TIME_WAIT</code>。我们注意到，在TCP的状态图中，从<code>TIME_WAIT</code>状态到<code>CLOSED</code>状态,有一个超时设置,这个超时设置是 <code>2*MSL</code>（RFC793定义了MSL为2分钟，Linux设置成了30s）为什么要这有<code>TIME_WAIT</code>？为什么不直接给转成CLOSED状态呢？主要有两个原因：1）<code>TIME_WAIT</code>确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL，2）有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。</p><h3 id="关于TCP的长链接与短连接"><a href="#关于TCP的长链接与短连接" class="headerlink" title="关于TCP的长链接与短连接"></a>关于TCP的长链接与短连接</h3><p>TCP的链接都是通过三次握手和四次挥手建立的，在一般情况下一般TCP是建立的短连接，一次数据传完就断开，这样也方便链接的管理。但是在某些需要频繁的交换数据的场景，这样就会浪费很多时间和资源在链接的建立和断开，所以这个时候就适合使用长连接进行通信。</p><h4 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h4><p>一般短连接是client向server发起连接请求，和server通过三次握手，建立连接。client和server两边进行一次通信，然后一次读写就完成了。通常这时候双方都可以发送FIN进行关闭连接，但是一般情况下都是client先进行发送，一般server不会回复完ACK后立即关闭连接，server端会在数据发送完后发送FIN进行关闭，一般一个链接进行一次通信，这样链接的管理比较方便，不需要额外的控制手段。</p><h4 id="长链接"><a href="#长链接" class="headerlink" title="长链接"></a>长链接</h4><p>长链接的情况比短连接复杂，client和server建立链接后，进行一次通信，在通信完成后，双方都不会发送FIN关闭链接，后续通信也可以继续使用该链接。而且链接的保活一般都是在server端进行的，在不进行通信的时候，server是处于一个半链接的状态，这个时候的server应该通过某种办法去获取client的状态，用来判断这个链接是否该关闭，不然对server资源占用是非常严重的，而且也非常没有必要，这个也叫TCP的保活。<br>TCP的保活一般有两种办法:<br>1、在应用层建立心跳机制:client在隔一段时间向server发送一次心跳包(一般都是很小的包，或者只包含包头的一个空包)，让server知道此时client的状态，server可以不对心跳包进行处理。<br>2、TCP协议的<code>KeepAlive</code>机制：当建立一个TCP连接时设置后<code>keepalive</code>后，就会将一系列的定时器与该连接相关联。这些定时器中某些用于处理keepalive过程。当keepalive定时器变为0时，client会发送一个<code>keepalive</code> 探针包（probe packet）到server，server在收到包后，会回应一个ACK。</p><hr><p>参考:<a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上）</a></p>]]></content>
      
      
      <categories>
          
          <category> TCP/IP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我理解的TCP协议(二)---超时与重传</title>
      <link href="/2017/02/08/%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84TCP%E5%8D%8F%E8%AE%AE(%E4%BA%8C)---%E9%87%8D%E4%BC%A0/"/>
      <url>/2017/02/08/%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84TCP%E5%8D%8F%E8%AE%AE(%E4%BA%8C)---%E9%87%8D%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">原文</a><br>TCP的可靠性不止建立在建立一个稳固的链接上，还有就是数据包丢失的重传机制,和防止网络波动的拥塞处理机制,这些都是慢慢发展而来的。<br>要先了解TCP的重传和拥塞处理,需要先了解两个很常见的变量–RTT和RTO,这两个是对重传和拥塞很重要的概念。</p><blockquote><p>RTT(Round Trip Time):就是发送一个数据包的往返时间的测量,由于路由器和网络流量均会变化，因此我们认为这个时间可能经常会发生变化，TCP应该跟踪这些变化并相应地改变其超时时间。<br>RTO(Retransmission TimeOut):重传超时时间,是根据RTT计算得到的。   </p></blockquote><h3 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h3><p>在重传机制中，首先在介绍重传的几个机制前，要注意。接收端给发送端的Ack确认只会确认最后一个连续的包,比如,发送端发了1,2,3,4,5一共五份数据，接收端收到了1,2,于是回ack 3,然后收到了4(注意此时3没收到，3丢失)此时的TCP会怎么办?我们要知道,因为正如前面所说的,<code>SeqNum和Ack是以字节数为单位,所以ack的时候,不能跳着确认,只能确认最大的连续收到的包</code>,不然,发送端就以为之前的都收到了。<br><a id="more"></a></p><h4 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h4><p>如果发送端决定死等3的ACK的话,等timeout后在重传3,然后接收端会回一个4(以为着3，4都收到了)。<br>但是有个问题很严重。在等3的超时的时候，由于4已经发送了,但是接收端不会发送4的ACK。说明在等3的时候，发送端会悲观的认为4也丢了。这个时候就会有两种选择：</p><ol><li>一种是仅重传第一个timeout的包。也就是第3份数据</li><li>第二种就是重传timeout后面所有的包，<br>这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等timeout，timeout可能会很长。<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4>TCP引入了一种叫Fast Retransmit的算法,<code>不以时间驱动,而以数据驱动重传</code>。也就是说，如果包没有连续到达,就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。<br>比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。示意图如下</li></ol><p>Fast Retransmit只解决了一个问题，就是timeout的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2呢还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个ack(2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些TCP的实际的实现）。可见，这是一把双刃剑。</p><h4 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h4><p>另外一种更好的方式叫：Selective Acknowledgment (SACK)（参看RFC 2018），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版。参看下图：<br><img src="http://ofa8x9gy9.bkt.clouddn.com/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0--SACK.png" alt><br>这样，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。于是就优化了Fast Retransmit的算法。当然，这个协议需要两边都支持。在 Linux下，可以通过tcp_sack参数打开这个功能（Linux 2.4后默认打开）。</p><p>这里还需要注意一个问题——接收方Reneging，所谓Reneging的意思就是接收方有权把已经报给发送端SACK里的数据给丢了。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。所以，发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time-Out，如果后续的ACK没有增长，那么还是要把SACK的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack。</p><p>注意：SACK会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆SACK的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。</p><hr><p>参考:<br><a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上）</a><br><a href="http://coolshell.cn/articles/11609.html" target="_blank" rel="noopener">TCP 的那些事儿（下）</a></p>]]></content>
      
      
      <categories>
          
          <category> TCP/IP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发系列(一) Java7的ConcurrentHashMap</title>
      <link href="/2017/01/18/%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97(%E4%B8%80)%20Java7%E7%9A%84ConcurrentHashMap/"/>
      <url>/2017/01/18/%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97(%E4%B8%80)%20Java7%E7%9A%84ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<p>从<a href="https://fluge.github.io/2016/12/15/HashMap%E5%B9%B6%E5%8F%91%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF/" target="_blank" rel="noopener">HashMap并发的死循环</a>可以知道,Hashmap是没办法在多线程的情况下使用的，为了解决这个问题，在Java4之前用的是hashtable,只是现在不推荐的。在Java5之后就比较推荐使用java.util.concurrent.ConcurrentHashMap，这个在多线程的情况下，也能有很好的性能。从这里引入了Java里面一类很重要的概念—并发。先解决完上一个问题。高并发下ConcurrentHashMap的结构。</p><h3 id="并发的一些初步了解–synchronized和volatile"><a href="#并发的一些初步了解–synchronized和volatile" class="headerlink" title="并发的一些初步了解–synchronized和volatile"></a>并发的一些初步了解–synchronized和volatile</h3><p>在多线程的并发的情况下有安全的访问变量，为了解决这个问题引入一个机制—锁机制。让多线程不能同时访问一个共享变量。在并发过程中有需要简单的了解两个东西的含义。</p><h4 id="Java中的synchronized的简单分析"><a href="#Java中的synchronized的简单分析" class="headerlink" title="Java中的synchronized的简单分析"></a>Java中的synchronized的简单分析</h4><p><code>synchronized</code>的用法要弄清晰一个问题:<code>synchronized</code>锁住的是代码还是对象？<br>首先是一个被<code>synchronized</code>修饰的代码块<br><a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       count = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + (count++));</span><br><span class="line">                   Thread.sleep(<span class="number">100</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在来看两段程序，这个概念可以清晰很多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一段代码</span></span><br><span class="line">SyncThread syncThread = <span class="keyword">new</span> SyncThread();</span><br><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(syncThread, <span class="string">"Thread A"</span>);</span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(syncThread, <span class="string">"Thread B"</span>);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二段代码</span></span><br><span class="line">SyncThread syncThread1 = <span class="keyword">new</span> SyncThread();</span><br><span class="line">SyncThread syncThread2 = <span class="keyword">new</span> SyncThread();</span><br><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(syncThread1, <span class="string">"Thread A"</span>);</span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(syncThread1, <span class="string">"Thread B"</span>);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure><p>这两段代码执行的结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一段代码的执行结果，两个线程依次顺序执行</span></span><br><span class="line">Thread A:<span class="number">0</span> </span><br><span class="line">Thread A:<span class="number">1</span> </span><br><span class="line">Thread A:<span class="number">2</span>  </span><br><span class="line">Thread B:<span class="number">3</span> </span><br><span class="line">Thread B:<span class="number">4</span> </span><br><span class="line">Thread B:<span class="number">5</span> </span><br><span class="line"><span class="comment">//第二段代码的执行结果，两个线程轮流执行</span></span><br><span class="line">Thread A:<span class="number">0</span> </span><br><span class="line">Thread B:<span class="number">1</span> </span><br><span class="line">Thread A:<span class="number">2</span> </span><br><span class="line">Thread B:<span class="number">3</span> </span><br><span class="line">Thread A:<span class="number">4</span> </span><br><span class="line">Thread B:<span class="number">5</span></span><br></pre></td></tr></table></figure><p>第一个结果是A，B两个线程按照锁的方式，依次执行。第二个结果是两个线程不受锁的控制交替执行，为什么会出现这个情况呢？主要是因为第一段代码中<code>线程A和线程B</code>都是访问<code>syncThread</code>这个一个对象，必须按照获得锁的顺序执行。但是在第二段代码中<code>线程A</code>访问的是<code>syncThread1</code>,<code>线程B</code>访问的是<code>syncThread2</code>,<code>线程A执行的是syncThread1对象中的synchronized代码(run)</code>,线程B一样。这就可以知道<code>synchronized</code>锁住的是对象，这时会有两把锁分别锁定syncThread A对象和syncThread B对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行。<br><code>synchronized</code>是一种同步锁它修饰的对象有以下几种： </p><ol><li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，上文的例子就是代码块，作用的对象是调用这个代码块的对象； </li><li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li><li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个<code>类</code>。  </li></ol><p>无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码</p><h4 id="Java中的volatile的简单分析"><a href="#Java中的volatile的简单分析" class="headerlink" title="Java中的volatile的简单分析"></a>Java中的volatile的简单分析</h4><p>Volatile是轻量级的synchronized，它在多处理器开发中保证了<code>共享变量</code>的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。<br>想要彻底的理解<code>volatile</code>就必须理解Java的内存模型这个会在下一篇里文章讲到。关于<code>volatile</code>要知道就是每当线程要访问一个被volatile修饰的变量时都会从内存中直接拉取，而不会从缓存中获取这个变量的值。</p><h3 id="Hashtable和—-已经淘汰的遗留并发的HashMap"><a href="#Hashtable和—-已经淘汰的遗留并发的HashMap" class="headerlink" title="Hashtable和—-已经淘汰的遗留并发的HashMap"></a>Hashtable和—-已经淘汰的遗留并发的HashMap</h3><p>简单说一下Hashtable和HashMap的区别：HashMap是非synchronized的适合在单线程下使用，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。Hashtable由于方法是由synchronized修饰的。可以在并发的情况下进行使用，只不过效率不高不建议使用。</p><h4 id="Hashtable源码的简单分析"><a href="#Hashtable源码的简单分析" class="headerlink" title="Hashtable源码的简单分析"></a>Hashtable源码的简单分析</h4><p>Hashtable源码和HashMap差不多。先看<code>put()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// Hashtable中不能插入value为null的元素！！！    </span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// “Hashtable中已存在键为key的键值对”,则用value替换    </span></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">                V old = entry.value;</span><br><span class="line">                entry.value = value;</span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addEntry(hash, key, value, index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//若“Hashtable中不存在键为key的键值对”，将“修改统计数”+1    </span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子)则扩容   </span></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">            rehash();</span><br><span class="line">            tab = table;</span><br><span class="line">            hash = key.hashCode();</span><br><span class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//将新的key-value对插入到tab[index]处（即链表的头结点）.</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从源码看基本和HashMap差不多。解决哈希冲突的方法一样。但是不允许为null的键值对。<code>get()</code>都差不多就不分析了。  </p><h4 id="Hashtable淘汰的原因"><a href="#Hashtable淘汰的原因" class="headerlink" title="Hashtable淘汰的原因"></a>Hashtable淘汰的原因</h4><p>HashTable容器使用synchronized来保证线程安全,但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时,其他线程访问HashTable的同步方法时,可能会进入阻塞或轮询状态。如线程1使用put进行添加元素,线程2不但不能使用put方法添加元素,并且也不能使用get方法来获取元素,所以竞争越激烈效率越低。<br>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争<code>同一把锁</code>,那假如容器里有多把锁,每一把锁用于锁容器其中一部分数据,那么当多线程访问容器里不同数据段的数据时,线程间就不会存在锁竞争,从而可以有效的提高并发访问效率,这就是ConcurrentHashMap所使用的<code>锁分段技术</code>,首先将数据分成一段一段的存储，然后给每一段数据配一把锁,当一个线程占用锁访问其中一个段数据的时候,其他段的数据也能被其他线程访问。  </p><h3 id="Java7的ConcurrentHashMap的结构分析和锁分段技术"><a href="#Java7的ConcurrentHashMap的结构分析和锁分段技术" class="headerlink" title="Java7的ConcurrentHashMap的结构分析和锁分段技术"></a>Java7的ConcurrentHashMap的结构分析和锁分段技术</h3><p>现在在Java8优化了Java7的的锁分段技术。取消了segment和Java8的Hashmap的优化一样。现在看Java7的锁分段技术，毕竟还是很有思考价值的。Java8的ConcurrentHashMap分析会在另一篇博文里面<br>Java7的ConcurrentHashMap的基本结构图,这个可以很清晰的认识到ConcurrentHashMap得内部存储结构。这个和HashMap的结构还是有很大差距的。不过有一点不会变的是:<code>两者的本质都是数组和链表的结合</code><br><img src="http://ofa8x9gy9.bkt.clouddn.com/Java7%E7%9A%84ConcurrentHashMap.png" alt><br>Java7的ConcurrenHashMap类中有两个静态内部类<code>HashEntry</code>和<code>Segment</code>。HashEntry 用来封装映射表的键值对;Segment用来充当锁的角色,每个<code>Segment</code>对象守护整个散列映射表的若干个桶。每个桶是由若干个 <code>HashEntry对象链接起来的链表</code>。一个ConcurrentHashMap实例中包含由若干个Segment对象组成的数组。Segment 在某些意义上有点类似于HashMap了，都是包含了一个数组，而数组中的元素可以是一个链表。</p><h4 id="HashEntry类"><a href="#HashEntry类" class="headerlink" title="HashEntry类"></a>HashEntry类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">       <span class="keyword">final</span> K key;                 <span class="comment">// 声明 key 为 final 型</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;              <span class="comment">// 声明 hash 值为 final 型 </span></span><br><span class="line">       <span class="keyword">volatile</span> V value;            <span class="comment">// 声明 value 为 volatile 型</span></span><br><span class="line">       <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;   <span class="comment">// 声明 next 为 final 型 </span></span><br><span class="line"></span><br><span class="line">       HashEntry(K key, <span class="keyword">int</span> hash, HashEntry&lt;K,V&gt; next, V value) &#123; </span><br><span class="line">           <span class="keyword">this</span>.key = key; </span><br><span class="line">           <span class="keyword">this</span>.hash = hash; </span><br><span class="line">           <span class="keyword">this</span>.next = next; </span><br><span class="line">           <span class="keyword">this</span>.value = value; </span><br><span class="line">       &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个里面需要注意的是  </p><ol><li><code>key</code>,<code>hash</code>,<code>next节点</code>都被声明为final型,这就意味着,发生了哈希冲突后,新来的节点只能插在头结点。而且链表原来的结构也没有被改变，插入新健 / 值对到链表中的操作不会影响读线程正常遍历这个链表。</li><li><code>value</code>被声明为volatile变量。用volatile来保证多个线程对数据的可见性。就为<code>get()</code>不加锁打下基础。  </li></ol><h4 id="Segment类"><a href="#Segment类" class="headerlink" title="Segment类"></a>Segment类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">       <span class="comment">//在本 segment 范围内，包含的 HashEntry 元素的个数 </span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count; </span><br><span class="line">       <span class="comment">//table 被更新的次数 </span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">int</span> modCount; </span><br><span class="line">       <span class="comment">//当 table 中包含的 HashEntry 元素的个数超过本变量值时，触发 table 的再散列</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * table 是由 HashEntry 对象组成的数组</span></span><br><span class="line"><span class="comment">        * 如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表</span></span><br><span class="line"><span class="comment">        * table 数组的数组成员代表散列映射表的一个桶</span></span><br><span class="line"><span class="comment">        * 每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分</span></span><br><span class="line"><span class="comment">        * 如果并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶总数的 1/16 </span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table; </span><br><span class="line">       <span class="comment">//装载因子 </span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">float</span> loadFactor; </span><br><span class="line">       Segment(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> lf) &#123; </span><br><span class="line">           loadFactor = lf; </span><br><span class="line">           setTable(HashEntry.&lt;K,V&gt;newArray(initialCapacity)); </span><br><span class="line">       &#125; </span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 设置 table 引用到这个新生成的 HashEntry 数组</span></span><br><span class="line"><span class="comment">        * 只能在持有锁或构造函数中调用本方法</span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">setTable</span><span class="params">(HashEntry&lt;K,V&gt;[] newTable)</span> </span>&#123; </span><br><span class="line">           <span class="comment">// 计算临界阀值为新数组的长度与装载因子的乘积</span></span><br><span class="line">           threshold = (<span class="keyword">int</span>)(newTable.length * loadFactor); </span><br><span class="line">           table = newTable; </span><br><span class="line">       &#125; </span><br><span class="line">       <span class="comment">//根据 key 的散列值，找到 table 中对应的那个桶（table 数组的某个数组成员） </span></span><br><span class="line">       <span class="function">HashEntry&lt;K,V&gt; <span class="title">getFirst</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123; </span><br><span class="line">           HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class="line">       <span class="comment">// 把散列值与 table 数组长度减 1 的值相“与”，得到散列值对应的 table 数组的下标然后返回 table 数组中此下标对应的 HashEntry 元素</span></span><br><span class="line">           <span class="keyword">return</span> tab[hash &amp; (tab.length - <span class="number">1</span>)]; </span><br><span class="line">       &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个里面需要注意的是：</p><ol><li><code>Segment</code>类是继承ReentrantLock类,这就是为了让Segment对象可以充当锁。每个Segment对象用来守护其(成员对象 table中)包含的若干个桶。</li><li><code>table</code>是一个由<code>HashEntry对象</code>组成的数组。table数组的每一个数组成员就是散列映射表的一个桶。</li><li><code>count</code>变量是一个计数器，它表示每个<code>Segment对象</code>管理的table数组(若干个HashEntry组成的链表)包含的HashEntry对象的个数。并且是<code>volatile</code>变量,所以当需要更新计数器时,不用锁定整个ConcurrentHashMap<h4 id="分段锁实现并发下的put-操作"><a href="#分段锁实现并发下的put-操作" class="headerlink" title="分段锁实现并发下的put()操作"></a>分段锁实现并发下的put()操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123; </span><br><span class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>)          <span class="comment">//ConcurrentHashMap中不允许用null作为映射值</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); </span><br><span class="line">       <span class="keyword">int</span> hash = hash(key.hashCode());        <span class="comment">// 计算键对应的散列码</span></span><br><span class="line">       <span class="comment">// 根据散列码找到对应的 Segment </span></span><br><span class="line">       <span class="keyword">return</span> segmentFor(hash).put(key, hash, value, <span class="keyword">false</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用 key 的散列码来得到 segments 数组中对应的 Segment </span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123; </span><br><span class="line">   <span class="comment">// 将散列值右移 segmentShift 个位，并在高位填充 0 </span></span><br><span class="line">   <span class="comment">// 然后把得到的值与 segmentMask 相“与”</span></span><br><span class="line">   <span class="comment">// 从而得到 hash 值对应的 segments 数组的下标值</span></span><br><span class="line">   <span class="comment">// 最后根据下标值返回散列码对应的 Segment 对象</span></span><br><span class="line">       <span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask]; </span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//在 Segment 中执行具体的 put 操作</span></span><br><span class="line">   <span class="function">V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123; </span><br><span class="line">           lock();  <span class="comment">// 加锁，这里是锁定某个Segment对象而非整个ConcurrentHashMap </span></span><br><span class="line">           <span class="keyword">try</span> &#123; </span><br><span class="line">               <span class="keyword">int</span> c = count; </span><br><span class="line">               <span class="keyword">if</span> (c++ &gt; threshold) &#123;    <span class="comment">// 如果超过再散列的阈值,执行再散列，table 数组的长度将扩充一倍</span></span><br><span class="line">                   rehash();  </span><br><span class="line">               &#125;</span><br><span class="line">               HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class="line">               <span class="comment">// 把散列码值与 table 数组的长度减 1 的值相“与”</span></span><br><span class="line">               <span class="comment">// 得到该散列码对应的 table 数组的下标值</span></span><br><span class="line">               <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>); </span><br><span class="line">               <span class="comment">// 找到散列码对应的具体的那个桶</span></span><br><span class="line">               HashEntry&lt;K,V&gt; first = tab[index]; </span><br><span class="line">               HashEntry&lt;K,V&gt; e = first; </span><br><span class="line">               <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key))) &#123;</span><br><span class="line">                   e = e.next; </span><br><span class="line">               &#125;</span><br><span class="line">               V oldValue; </span><br><span class="line">               <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;            <span class="comment">// 如果键 / 值对以经存在</span></span><br><span class="line">                   oldValue = e.value; </span><br><span class="line">                   <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                       e.value = value;    <span class="comment">// 设置 value 值</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; </span><br><span class="line">               <span class="keyword">else</span> &#123;                        <span class="comment">// 键 / 值对不存在 </span></span><br><span class="line">                   oldValue = <span class="keyword">null</span>; </span><br><span class="line">                   ++modCount;         <span class="comment">// 要添加新节点到链表中，所以 modCont 要加 1  </span></span><br><span class="line">                   <span class="comment">// 创建新节点，并添加到链表的头部 </span></span><br><span class="line">                   tab[index] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(key, hash, first, value); </span><br><span class="line">                   count = c;               <span class="comment">// 写 count 变量</span></span><br><span class="line">               &#125; </span><br><span class="line">               <span class="keyword">return</span> oldValue; </span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">               unlock();                     <span class="comment">// 解锁</span></span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ol><p>在这个里面需要注意的是:这里的<code>加锁操作</code>是针对(键的hash值对应的)<code>某个具体的Segment</code>,锁定的是该Segment而不是整个ConcurrentHashMap。因为插入键值对的操作只是在这个Segment包含的某个桶中完成,不需要锁定整个ConcurrentHashMap。此时,其他写线程对另外15个Segment的加锁并不会因为当前线程对这个Segment的加锁而阻塞。同时,所有读线程几乎不会因本线程的加锁而阻塞,除非读线程刚好读到这个Segment中某个HashEntry的value域的值为null,此时需要加锁后重新读取该值。  </p><h3 id="小小的总结"><a href="#小小的总结" class="headerlink" title="小小的总结"></a>小小的总结</h3><p>这次的并发下的优化的具体方向是根据一些试用场景优化的:除了少数插入操作和删除操作外，绝大多数都是读取操作，而且读操作在大多数时候都是成功的。原来的Hashtable的<code>synchronized</code>直接加锁的方式,会在<code>put()</code>操作的时候同时会阻塞其他线程的<code>get()</code>操作。ConcurrentHashMap就多次采用<code>volatile</code>变量来解决变量在<code>JMM(Java内存模型)</code>中对其他线程可见性。这也可以使<code>volatile</code>对<code>synchronized</code>锁的优化。<br>用分段锁去优化<code>synchronized</code>的<code>put()</code>操作的阻塞。就在于<code>减少多个线程对同一个锁的请求频率</code>和<code>减少线程对锁的持有时间</code>,就是减小锁的细粒度来优化锁的阻塞。</p><hr><p>参考:<br><a href="http://blog.csdn.net/luoweifu/article/details/46613015" target="_blank" rel="noopener">Java中Synchronized的用法</a><br><a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/" target="_blank" rel="noopener">探索 ConcurrentHashMap 高并发性的实现机制</a><br><a href="http://wiki.jikexueyuan.com/project/java-collection/concurrenthashmap.html" target="_blank" rel="noopener">ConcurrentHashMap 的实现原理</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>session和cookie</title>
      <link href="/2016/12/22/session%E5%92%8Ccookie/"/>
      <url>/2016/12/22/session%E5%92%8Ccookie/</url>
      
        <content type="html"><![CDATA[<h3 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h3><p>首先有一点必须特别的清楚： 因为HTTP协议是无状态的，客户每次读取web页面时，服务器都打开新的会话，而且服务器也不会自动维护客户的上下文信息，对于一个浏览器发出的多次请求，WEB服务器无法区分 是不是来源于同一个浏览器，更别说是否是来自同一用户。为了保持用户的状态，有了两种机制，一般用户客户端的cookie机制，和用于服务器端的session机制，这两种机制都是为了保持状态，既有联系又有区别。</p><h3 id="cookie基本实现机制"><a href="#cookie基本实现机制" class="headerlink" title="cookie基本实现机制"></a>cookie基本实现机制</h3><p>现在的cookie是HTTP协议的一部分，一般存在HTTP的响应头，内容是一系列的键值对的形式，简单说：cookie就是服务器在用户的浏览器中存储的一小段文本文件（大小不能超过3K）不包含任何可执行代码，里面一般包含的是用户的登录信息之类的比较少的，用来验证用户是否合法（不止局限与此，cookie是用来记录状态的，也可以是购物的等一系列状态，让服务器知道我们浏览了那些地方，购物对那些感兴趣，一般很多广告都是根据这个东西来推送的，你在某购物网站买了一个东西，然后浏览别的网站，发现广告都是和你浏览的相关）。  cookie的内容主要包括：key-value,Expires（过期时间），path和domain。path和domain一起构成cookie的作用范围。<br><img src="http://ofa8x9gy9.bkt.clouddn.com/cookie.png" alt><br>&emsp;&emsp;&emsp;&emsp;现在的cookie，内容经过加密了<br>cookie的实现流程：  </p><ol><li>浏览器向某个URL发起HTTP请求 （可以是任何请求，比如GET，POST等）</li><li>对应的服务器收到该HTTP请求，并做相应的响应（响应头和请求体两部分），在响应的头中加入<code>Set-Cookie</code>字段（设置相应的cookie，cookie是多个<code>key-value</code>组成的）<a id="more"></a></li><li>浏览器收到来自服务器的HTTP响应</li><li>浏览器在响应头中发现存在<code>Set-Cookie</code>字段，就会将相应的cookie(key-value)保存在内存或者硬盘中。需要注意的是<code>Set-Value</code>字段可以包含多个cookie,每一项都可以指定过期时间，默认的过期的时间是用户浏览器关闭的时候</li><li>浏览器下次给该服务器发送HTTP请求时，会将服务器设置的cookie附加在HTTP请求头<code>Cookie</code>中浏览器可以存储多个不同域名下的Cookie，但只发送当前请求的域名曾经指定的域名，这个可以在<code>Set-Cookie</code>中指定</li><li>服务器收到这个HTTP请求，发现请求头中有<code>Cookie</code>字段，就知道这个用户的状态。获取相应的信息进行响应。<br>这就是整个基本的cookie机制。保存了用户的操作状态，但是还需要注意的是,cookies是通过明文传递。在HTTP包中容易被劫持和伪造，是不安全的，不应该存一些比较重要的东西。还有就是cookie在整个会话都会在HTTP的请求中，增加了流量。     </li></ol><h3 id="session的基本实现机制"><a href="#session的基本实现机制" class="headerlink" title="session的基本实现机制"></a>session的基本实现机制</h3><p>有一个session是不能改变的，是为了维持住HTTP的状态，所以在用户每次发起HTTP请求的时候，都需要让服务器知道是那个用户发起的这个请求，然后查找这个用户的状态，在进行相应的处理。session的实现基于这点，就需要一个唯一的ID标志某个用户（session）然后在这个ID中对应多个键值对来保证用户的状态，所以前后端只需要传递一个sessionId，服务器就可找到对应的状态（这个对应的键值对可以存在redies或者数据库中）。前后端传递值基本有三种：一种是直接写在URL中，一种通过表单中的隐藏域来提交，还有一种是现在流行的做法，通过在cookie中设置一个键值对<code>jsessionId=${sessionId}</code>在传递。现在第一二种都不是很建议这么做，当然在浏览器禁用的情况下也可以通过前面两种来传递，不过一般浏览器都支持使用cookie的方式。 </p><h3 id="两种方式的区别和联系"><a href="#两种方式的区别和联系" class="headerlink" title="两种方式的区别和联系"></a>两种方式的区别和联系</h3><ol><li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li><li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</li><li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>考虑到减轻服务器性能方面，应当使用cookie。</li><li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。<br>联系是：两个都是用来保持HTTP协议状态的方式，一种是客户端的实现，一种是服务器端的实现。但是session可以依赖于cookie来传递sessionId</li></ol><h3 id="一个小项目例子–在微信中开发的小程序（公众号自动回复）里面的session问题"><a href="#一个小项目例子–在微信中开发的小程序（公众号自动回复）里面的session问题" class="headerlink" title="一个小项目例子–在微信中开发的小程序（公众号自动回复）里面的session问题"></a>一个小项目例子–在微信中开发的小程序（公众号自动回复）里面的session问题</h3><p>首先简单描述下小项目:用户在公众号中输入某一个触发关键词（项目里面的例子是：绑定），然后就进入绑定所涉及的流程。用户在公众中输入触发词，是由微信的服务器进行响应，然后转发到程序的服务器。程序的服务器在把处理的结果（用规定的格式）传递给微信的服务器，由微信的服务器进行响应给用户。整个项目用golang开发，简单的使用了beego框架。</p><h4 id="基于session来实现（初始版）"><a href="#基于session来实现（初始版）" class="headerlink" title="基于session来实现（初始版）"></a>基于session来实现（初始版）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *MainController)</span> <span class="title">Dispatch</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//进行请求的分发，和request数据的解析,POST</span></span><br><span class="line">w := <span class="built_in">new</span>(models.WeixinUser)</span><br><span class="line">xml.Unmarshal(c.Ctx.Input.RequestBody,&amp;w)</span><br><span class="line"><span class="comment">//第一步是判断是否为开启逻辑的语句，同一个逻辑只能同时开启一次</span></span><br><span class="line">str:=w.Content</span><br><span class="line">sc:=c.GetSession(<span class="string">"status-count"</span>).(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">switch</span> str &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"绑定"</span>: <span class="comment">//如果匹配进入绑定，判断是否同时开启两次</span></span><br><span class="line">str0:=<span class="string">""</span></span><br><span class="line">binds:=assertionInt(c.GetSession(<span class="string">"bindstep"</span>))</span><br><span class="line"><span class="keyword">if</span> binds==<span class="number">-1</span>&#123;</span><br><span class="line">c.SetSession(<span class="string">"bindstep"</span>,<span class="keyword">int</span>(<span class="number">1</span>))</span><br><span class="line">sc++;</span><br><span class="line">c.SetSession(<span class="string">"status-count"</span>,<span class="keyword">int</span>(sc))</span><br><span class="line">c.SetSession(<span class="string">"status-"</span>+strconv.Itoa(sc),<span class="keyword">string</span>(<span class="string">"bind"</span>))</span><br><span class="line">_,str0=bind(c,w)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> str0==<span class="string">""</span>&#123;</span><br><span class="line">str0=<span class="string">"已经进入绑定流程"</span></span><br><span class="line">&#125;</span><br><span class="line">prints(c,w,str0)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步判断有多少个session保持者状态，从0开始计数,输入的数据从最上面的应用进行匹配处理</span></span><br><span class="line"><span class="keyword">if</span> sc &gt;=<span class="number">0</span> &#123;<span class="comment">//判断是否有触发的逻辑</span></span><br><span class="line"><span class="keyword">for</span> i:=sc;i&gt;=<span class="number">0</span>;i--&#123;<span class="comment">//进行逻辑匹配</span></span><br><span class="line">str2:=c.GetSession(<span class="string">"status-"</span>+strconv.Itoa(i)).(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> str2!=<span class="string">""</span>&#123;</span><br><span class="line">str1:=<span class="string">" "</span><span class="comment">//进行默认的逻辑处理，不做回应</span></span><br><span class="line"><span class="keyword">switch</span> str2 &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"bind"</span>:</span><br><span class="line">code,src:=bind(c,w)<span class="comment">//code用来处理完成逻辑后的删除session的作用</span></span><br><span class="line"><span class="keyword">if</span> code==<span class="number">1</span>&#123;</span><br><span class="line">c.DelSession(<span class="string">"status-"</span>+strconv.Itoa(i))</span><br><span class="line">c.SetSession(<span class="string">"status-count"</span>,<span class="keyword">int</span>(sc<span class="number">-1</span>))</span><br><span class="line">sc--;</span><br><span class="line">&#125;</span><br><span class="line">str1=src</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> str1 != <span class="string">" "</span>&#123;<span class="comment">//如果进行处理就退出逻辑</span></span><br><span class="line">prints(c,w,str1)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> str1 ==<span class="string">" "</span>&amp;&amp;i==<span class="number">0</span>&#123;</span><br><span class="line">str1=<span class="string">"输入格式错误"</span></span><br><span class="line">prints(c,w,str1)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">str=<span class="string">"输入：绑定，可以进入绑定流程"</span></span><br><span class="line">prints(c,w,str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bind</span><span class="params">(c *MainController,w *models.WeixinUser)</span> <span class="params">(<span class="keyword">int</span>,<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//进行绑定请求的处理，如果匹配不上，退出同时开始另一个逻辑的匹配</span></span><br><span class="line">step:=c.GetSession(<span class="string">"bindstep"</span>).(<span class="keyword">string</span>)<span class="comment">//内部逻辑计数器，记住用户的处理的位置，从1开始计数</span></span><br><span class="line"><span class="keyword">if</span> step==<span class="number">1</span>||step==<span class="number">2</span>||step==<span class="number">3</span>||step==<span class="number">4</span>&#123;</span><br><span class="line"><span class="keyword">switch</span> step &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//用户输入进入词，进入逻辑</span></span><br><span class="line">c.SetSession(<span class="string">"bindstep"</span>,<span class="keyword">int</span>(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>,<span class="string">"请输入手机号，进行绑定"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//用户输入了手机号，发送短信，获取验证码</span></span><br><span class="line"><span class="comment">//todo 验证手机号格式并且发短信验证验证码</span></span><br><span class="line">ok:=validatePhone(w.Content)</span><br><span class="line"><span class="keyword">if</span> !ok&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>,<span class="string">"手机号格式不正确，请重新输入"</span></span><br><span class="line">&#125;</span><br><span class="line">alidayu.AppKey=<span class="string">"*******"</span></span><br><span class="line">alidayu.AppSecret=<span class="string">"**************"</span></span><br><span class="line">alidayu.UseHTTP=<span class="literal">true</span></span><br><span class="line">str:=randNum()<span class="comment">//生成随机4位数字</span></span><br><span class="line">success,_:=alidayu.SendSMS(w.Content,<span class="string">"德玛西亚"</span>,<span class="string">"********"</span>, <span class="string">`&#123; "code":"`</span>+str+<span class="string">`"&#125;`</span>)</span><br><span class="line"><span class="keyword">if</span> !success&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>,<span class="string">"验证码发送失败，请重新输入手机号"</span></span><br><span class="line">&#125;</span><br><span class="line">c.SetSession(<span class="string">"rand"</span>,str)</span><br><span class="line">f:=models.Fluge&#123;&#125;</span><br><span class="line">f.Openid=w.FromUserName</span><br><span class="line">f.Phone=w.Content</span><br><span class="line">c.SetSession(<span class="string">"fluge"</span>,f)</span><br><span class="line">c.SetSession(<span class="string">"bindstep"</span>,<span class="keyword">int</span>(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>,<span class="string">"验证码已发送，请输入验证码完成绑定"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//进行验证码的验证，成功就开始绑定</span></span><br><span class="line"><span class="keyword">if</span> w.Content==c.GetSession(<span class="string">"rand"</span>).(<span class="keyword">string</span>) &#123;</span><br><span class="line">f:=c.GetSession(<span class="string">"fluge"</span>).(*models.Fluge)</span><br><span class="line">c.DelSession(<span class="string">"fluge"</span>)</span><br><span class="line">c.DelSession(<span class="string">"rand"</span>)</span><br><span class="line">flag,_:=models.CheckUser(f)</span><br><span class="line"><span class="keyword">if</span> flag &#123;</span><br><span class="line">str3, err := models.AddUser(f)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, str3</span><br><span class="line">&#125;</span><br><span class="line">c.SetSession(<span class="string">"bindstep"</span>, <span class="keyword">int</span>(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, str3</span><br><span class="line">&#125;</span><br><span class="line">c.SetSession(<span class="string">"bindstep"</span>,<span class="keyword">int</span>(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>,<span class="string">"手机号无法重复绑定，请重新输入手机号"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>,<span class="string">"验证码错误，请重新输入"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//用户已经完成绑定，等待退出</span></span><br><span class="line"><span class="keyword">if</span> w.Content==<span class="string">"8"</span> &#123;</span><br><span class="line">c.DelSession(<span class="string">"bindstep"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>,<span class="string">"谢谢使用"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>,<span class="string">"绑定完成，请输入8退出"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>,<span class="string">" "</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个程序是执行不了的。在beego中默认传递sessionId是cookie。但如果我在程序中必须使用session保持用户的状态（不然流程没办法继续下去）。两个服务器之间的交互式没有办法传递cookie。所以就会出现在一直在第一个流程，无法进入第二个流程。  </p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>首先明白一点，sessionId的作用是一个唯一标识符，用来标记同一个用户。但是在微信的整个架构中有一个跟sessionId很类似的东西:openid:用户对于某个公众号唯一的标识。所以在微信服务器向程序的服务器提交POST消息市本身也会自带这个openid。这样就为解决session提供了遍历。<br>不需要额外去产生和传递sessionId。直接使用openid来作为用户的唯一标识符。<br><img src="http://ofa8x9gy9.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A5%E5%8F%97%E6%B6%88%E6%81%AF.png" alt><br>然后对于sessionId对应的具体内容我选择了方便的redis来存储<br>实现代码–直接复写了beego的Getseeion和SetSession方法    </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *MainController)</span><span class="title">initSession</span><span class="params">(sid <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">config := &amp;redissession.SessionConfig&#123;</span><br><span class="line">Prefix:<span class="string">"lyfluge-"</span>,</span><br><span class="line">RedisHost:<span class="string">"**********"</span>,</span><br><span class="line">RedisPassword:<span class="string">"f***********"</span>,</span><br><span class="line">LifeTime: <span class="number">60</span> * time.Second,</span><br><span class="line">&#125;</span><br><span class="line">c.sesion = redissession.NewSession(<span class="string">"redis"</span>,config)</span><br><span class="line">c.sesion.SetSessionID(sid)</span><br><span class="line">c.sesion.Start()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *MainController)</span><span class="title">storeSession</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.sesion.Store()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *MainController)</span> <span class="title">SetSession</span><span class="params">(str <span class="keyword">string</span>,value <span class="keyword">interface</span>&#123;&#125;)</span><span class="title">interface</span></span>&#123;&#125;&#123;</span><br><span class="line"><span class="keyword">return</span> c.sesion.Set(str,value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *MainController)</span> <span class="title">GetSession</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">interface</span></span>&#123;&#125;&#123;</span><br><span class="line"><span class="keyword">return</span> c.sesion.Get(str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *MainController)</span> <span class="title">DelSession</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">interface</span></span>&#123;&#125;&#123;</span><br><span class="line"><span class="keyword">return</span> c.sesion.Delete(str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在Dispatch函数中取到对应的sessionId，然后进行状态判断</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *MainController)</span> <span class="title">Dispatch</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//进行请求的分发，和request数据的解析.POST</span></span><br><span class="line">w := <span class="built_in">new</span>(models.WeixinUser)</span><br><span class="line">xml.Unmarshal(c.Ctx.Input.RequestBody,&amp;w)</span><br><span class="line">c.initSession(w.FromUserName)</span><br><span class="line">   /..../</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码(包括微信golang的接入,大鱼短信,beego,session-redis的具体实现):</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>session中的sessionId是用来标志唯一用户的。通过找到这个用户来判断用户的状态  </p><hr><p>参考:<a href="http://harttle.com/2015/08/10/cookie-session.html" target="_blank" rel="noopener">Cookie/Session的机制与安全</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> session </tag>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap的并发死循环</title>
      <link href="/2016/12/15/HashMap%E5%B9%B6%E5%8F%91%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF/"/>
      <url>/2016/12/15/HashMap%E5%B9%B6%E5%8F%91%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p>HashMap从设计上来说就不适合在并发的情况的下使用,因为HashMap每次在<code>put()</code>时，总会检查一遍对应桶的容量，如果桶满了，或者超过了设定的值，就会<code>reserve()</code>来进行扩容,然后通过<code>get()</code>来取出相应的值。这个过程在单线程下是没什么问题的，但是如果在并发的条件下，多个线程同时reserve桶，然后有线程这个时候执行<code>get()</code>就有可能产生死循环，造成CPU的100%占用，具体等会看源码。在Java里面有一个很老的hashtable就是加了锁的HashMap。现在Java中多线程里一般使用ConcurrentHashMap，至于为什么。会在下一篇博文里分析。</p><h3 id="HashMap的rehash源代码"><a href="#HashMap的rehash源代码" class="headerlink" title="HashMap的rehash源代码"></a>HashMap的rehash源代码</h3><p><code>put()</code>方法的Java8源码分析看我的<a href="https://fluge.github.io/2016/12/05/Java%E9%87%8C%E7%9A%84hasMap%E5%92%8Cgolang%E9%87%8C%E7%9A%84map/" target="_blank" rel="noopener">Java里的hashMap和golang里的map</a>，在Java8中优化了扩容的hash算法，更加高效。在这分析死循环用的是Java7的源码。更加清晰点。<br><a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//创建一个新的Hash Table</span></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">        <span class="comment">//将Old Hash Table上的数据迁移到New Hash Table上</span></span><br><span class="line">        transfer(newTable, initHashSeedAsNeeded(newCapacity))</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前table的Entry转移到新的table中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span></span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">//下面这段代码的意思是:从OldTable里摘一个元素出来，然后放到NewTable中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="comment">//在新的table 中求得适合插入的位置</span></span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);<span class="comment">// 可能导致死循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在单线程中的执行流程其实是很直观的:先对要插入的元素进行哈希，在数组中找到相应的位置，如果发生冲突就变成链表存储，在看桶有没有满。有就进<code>resize()</code>扩容操作。但是在多线程的时候由于扩容操作产生<code>环形链</code>，会造成<code>get()</code>方法命中时—-Infinite Loop,然后CPU爆炸。  </p><h4 id="举例分析-网上一个很经典的例子–引用自酷壳"><a href="#举例分析-网上一个很经典的例子–引用自酷壳" class="headerlink" title="举例分析(网上一个很经典的例子–引用自酷壳)"></a>举例分析(网上一个很经典的例子–引用自酷壳)</h4><p>假设我们的hash算法是简单的key mod一下表的大小(即数组的长度),现在有两个线程：一个蓝色标注，一个红色标注。<br>关键代码在<code>transfer()</code>中把旧的table的Entry转移到新的table中的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">     Entry&lt;K,V&gt; next = e.next;&lt;--假设红色线程执行到这里就被调度挂起了,蓝色线程全部执行</span><br><span class="line">     <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">     e.next = newTable[i];</span><br><span class="line">     newTable[i] = e;</span><br><span class="line">     e = next;</span><br><span class="line">&#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>两个线程在蓝色线程执行完后的情况。这个时候红色线程中的<code>e指向了key(3)</code>,而<code>next指向了key(7)</code>,但是在蓝色线程中<code>链表已经扩容完成</code>,并且<code>链表的顺序被反转</code> ,这个时候就有了环链的征兆了。e的下一个节点本来是next,经过蓝色线程扩容后变成了next下一个节点是e。就有很大的几率产生环形链。<br><img src="http://ofa8x9gy9.bkt.clouddn.com/JAVA%20HASHMAP%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF.jpg" alt><br>接着看,这个时候红色线程得到了执行的机会.被调度回来进行执行，<br>先是执行<code>newTalbe[i] = e;</code>,然后是<code>e = next，导致了e指向了key(7)</code>,而下一次循环的<code>next = e.next导致了next指向了key(3)</code>。<br><img src="http://ofa8x9gy9.bkt.clouddn.com/HashMap03.jpg" alt><br>然后红色线程接着工作,把key(7)摘下来，放到newTable[i]的第一个,然后把<code>e和next往下移</code>。<br><img src="http://ofa8x9gy9.bkt.clouddn.com/HashMap04.jpg" alt><br>然后重点来了：<code>e.next = newTable[i]</code>导致<code>key(3).next指向了key(7)</code>。但是此时的<code>key(7).next 已经指向了key(3)</code>,环形链表就这样出现了。<br><img src="http://ofa8x9gy9.bkt.clouddn.com/HashMap05.jpg" alt><br>于是,当我们的线程一调用到,HashTable.get(11)时,悲剧就出现了——Infinite Loop。</p><hr><p>参考：<br><a href="http://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">疫苗：Java HashMap的死循环</a><br><a href="http://ifeve.com/hashmap-infinite-loop/" target="_blank" rel="noopener">不正当使用HashMap导致cpu 100%的问题追究</a> </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域</title>
      <link href="/2016/12/14/%E8%B7%A8%E5%9F%9F/"/>
      <url>/2016/12/14/%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>这套安全策略由Netscape提出，并延续至今。它规定：JavaScript脚本只能访问与其同一来源的资源(现在很多资源是通过ajax发起异步请求来获取的，如果没有跨域这个是禁止的)。<br>所谓同源是指，域名，协议，端口相同。不同源的客户端脚本(javascript、ActionScript)在没明确授权的情况下，不能读写对方的资源。严格隔离不相关的网站提供的内容，防止客户端数据机密性或完整性丢失。<br>假设你已经成功登录Gmail服务器，同时在同一个浏览器访问恶意站点（另一个浏览器选项卡）。没有同源策略，攻击者可以通过JavaScript获取你的用户信息，你的邮件以及其他敏感信息，比如说阅读你的私密邮件，发送虚假邮件，看你的聊天记录等等。假如把这个换成银行账户，那就很恐怖了。<br>可以说同源策略是现如今浏览器安全的基石。但是如果不能突破同源策略，把所有的资源放在同一服务器下，现在看来是不现实，必须有一中方式去平衡这种安全和便捷的机制–跨域。现在一般的跨域使用的是CORS(基本所有浏览器支持)和JSONP(一些比较的老的应用使用)。  </p><h3 id="CROS跨域"><a href="#CROS跨域" class="headerlink" title="CROS跨域"></a>CROS跨域</h3><p>CORS是一个W3C标准，全称是”跨域资源共享”(Cross-origin resource sharing)。它允许浏览器向跨源服务器,发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>简单说一下我对CROS的理解。就相当于我想跟一个邻居借东西(浏览器向服务器发送跨域请求)。我首先要去敲门，然后就是几种情况，一种是邻居家里你敲门没有反应(服务器端没有设置跨域)，你跟不知道邻居家里的具体情况，借东西肯定是失败的。一种是邻居进行了应答，但是告诉你我跟你不熟，不借东西给你。另外一种就是邻居进行了应答，并借给你东西。<br><a id="more"></a><br>要了解CROS跨域，首先需要知道浏览器在ajax发起跨域请求的时候做了什么事。<br><code>每次浏览器检查到这个请求是跨域请求时,会在请求的头部添加一些附加的头信息,根据请求的不同,有时会多发起一次请求</code>但是这些用户是感觉不到，前端的ajax调用也没有发什么变化,改变的是服务器端的回应。所以cros跨域由于浏览器的支持，现在只要在服务器端，也就是后端进行配置就可以了。  </p><h4 id="cros分类"><a href="#cros分类" class="headerlink" title="cros分类"></a>cros分类</h4><p>浏览器将cros的跨域请求分为两种:一种是简单请求，一种的非简单请求，两种的区别就是在发起非简单请求的时候，浏览器会在请求的前面先发起一次预请求，看请求的后端是否允许当前这个域名和这个方法进行访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">简单请求(不满足以下条件的都是非简单请求):</span><br><span class="line">(<span class="number">1</span>)请求方法是以下三种方法之一:</span><br><span class="line">HEAD</span><br><span class="line">GET</span><br><span class="line">POST</span><br><span class="line">(<span class="number">2</span>)HTTP的头信息不超出以下几种字段:</span><br><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type:只限于三个值application/x-www-form-urlencoded 或 multipart/form-data 或text/plain</span><br></pre></td></tr></table></figure><h4 id="cros的简单请求"><a href="#cros的简单请求" class="headerlink" title="cros的简单请求"></a>cros的简单请求</h4><p>对于简单请求的cros跨域请求,浏览器会在就是在头信息之中，增加一个<code>Origin</code>字段用来说明,本次请求来自哪个源(协议 + 域名 + 端口)服务器根据这个值，决定是否同意这次请求。<br>如果<code>Origin</code>的字段在服务器端允许的范围内,服务器成功响应,会在返回的头信息中多几个字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</span></span><br><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line"><span class="comment">//该字段可选。它的值是一个布尔值，表示是否允许发送Cookie</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="keyword">true</span></span><br><span class="line"><span class="comment">//该字段可选。</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br></pre></td></tr></table></figure><p>如果<code>Origin</code>指定的域名不在许可范围内。服务器也会正常的返回HTTP的回应(状态吗有可能是200)，只是头信息里面不会增加上面的字段。浏览器收到回应后 会检测是否有<code>Access-Control-Allow-Origin</code>字段，如果没有回抛出一个错误，被XMLHttpRequest的onerror回调函数捕获</p><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>非简单请求就是不满足简单请求条件的都是非简单请求，值得注意的是<code>Content-Type: application/josn</code>都是非简单请求。<br>浏览器如果检测到发起的请求是非简单请求，会在正式发起HTTP请求前,浏览器会自动发起一次HTTP查询请求，称为”预检”请求（preflight）。<br>预请求的方法是<code>OPTIONS</code>,这个方法和GET,POST等方法是一样的。这个方法表示请求是用来询问的服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">一个预检请求</span><br><span class="line">OPTIONS /cors HTTP/<span class="number">1.1</span></span><br><span class="line"><span class="comment">//表示请求来自哪个源。</span></span><br><span class="line">Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line"><span class="comment">//该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，这个是PUT。</span></span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line"><span class="comment">//该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</span></span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br><span class="line"></span><br><span class="line">预检请求允许,服务器端的回应</span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Date: Mon, <span class="number">01</span> Dec <span class="number">2008</span> <span class="number">01</span>:<span class="number">15</span>:<span class="number">39</span> GMT</span><br><span class="line">Server: Apache/<span class="number">2.0</span>.61 (Unix)</span><br><span class="line"><span class="comment">//表示http://api.bob.com可以请求数据。该字段也可以设为*，表示同意任意跨源请求。</span></span><br><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line"><span class="comment">//该字段必需，表明服务器支持的所有跨域请求的方法。</span></span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: <span class="number">0</span></span><br><span class="line">Keep-Alive: timeout=<span class="number">2</span>, max=<span class="number">100</span></span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain;</span><br><span class="line"></span><br><span class="line">预检请求被否定时,跟简单请求一样会回复一个正常的HTTP请求,然后浏览器检查，被被XMLHttpRequest对象的onerror回调函数捕获就会报错</span><br><span class="line">XMLHttpRequest cannot load http:<span class="comment">//api.alice.com.</span></span><br><span class="line">Origin http:<span class="comment">//api.bob.com is not allowed by Access-Control-Allow-Origin.</span></span><br></pre></td></tr></table></figure><p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p><h4 id="beego的跨域"><a href="#beego的跨域" class="headerlink" title="beego的跨域"></a>beego的跨域</h4><p>在工作中用beego框架遇到的跨域问题的解决</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">beego.InsertFilter(<span class="string">"*"</span>, beego.BeforeRouter,cors.Allow(&amp;cors.Options&#123;</span><br><span class="line"><span class="comment">//允许的访问的域名</span></span><br><span class="line">AllowOrigins:  []<span class="keyword">string</span>&#123;<span class="string">"*"</span>&#125;,</span><br><span class="line"><span class="comment">//允许的访问的方法</span></span><br><span class="line">AllowMethods:  []<span class="keyword">string</span>&#123;<span class="string">"OPTIONS"</span>,<span class="string">"GET"</span>,<span class="string">"PUT"</span>,<span class="string">"DELETE"</span>,<span class="string">"POST"</span>&#125;,</span><br><span class="line">AllowHeaders:  []<span class="keyword">string</span>&#123;<span class="string">"Origin"</span>&#125;,</span><br><span class="line">ExposeHeaders: []<span class="keyword">string</span>&#123;<span class="string">"Content-Length"</span>&#125;,</span><br><span class="line">AllowCredentials: <span class="literal">true</span>,</span><br><span class="line">&#125;))</span><br><span class="line">beego.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JSONP的简介"><a href="#JSONP的简介" class="headerlink" title="JSONP的简介"></a>JSONP的简介</h4><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。<br>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p><hr><p>参考:<br><a href="http://blog.leanote.com/post/tamamoran/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%8F%8A%E7%AA%81%E7%A0%B4%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">浏览器的同源策略及突破方法</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICMP协议和UDP协议</title>
      <link href="/2016/12/12/ICMP%E5%8D%8F%E8%AE%AE%E5%92%8CUDP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2016/12/12/ICMP%E5%8D%8F%E8%AE%AE%E5%92%8CUDP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="ICMP网络控制报文协议"><a href="#ICMP网络控制报文协议" class="headerlink" title="ICMP网络控制报文协议"></a>ICMP网络控制报文协议</h3><p>ICMP经常被认为是IP层的一个组成部分,它传递差错报文以及其他需要注意的信息。ICMP报文通常被IP层或更高层协议（UDP,TCP）使用。ICMP报文是在IP数据报内部传输的。由于IP是不可靠的协议，不能保证IP数据报能够成功到达目的主机，无法进行差错控制。但是这些信息会由ICMP将错误信息封包，然后传递给主机，让主机有处理错误的机会。<br><img src="http://ofa8x9gy9.bkt.clouddn.com/ICMP%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F.png" alt><br>ICMP数据报由8bit的错误类型和8bit的代码（表示制定类型中的一个功能，如果只有一个功能，代码就置0）以及16bit的校验和组成，检验和字段覆盖整个ICMP报文。<br>ICMP报文大致可以分为：差错报文和查询报文。因为对ICMP的差错报文需要做一些特殊响应，需要进行区分。比如在对差错报文进行响应的时候，永远不会产生另一个ICMP差错报文，防止不断的产生差错一直循环。同时一下几种情况也不会产生ICMP差错报文：</p><ol><li>ICMP差错报文不会产生</li><li>目的地址是广播地址或多播地址的IP数据报</li><li>作为链路层广播的数据报</li><li>不是IP分片的第一片</li><li>源地址不是单个主机的数据报  <a id="more"></a>  </li></ol><p><img src="http://ofa8x9gy9.bkt.clouddn.com/ICMP%E5%B7%AE%E9%94%99%E6%95%B0%E6%8D%AE%E6%8A%A5.png" alt><br>ICMP查询报文：</p><ol><li>ping查询 </li><li>子网掩码查询：用于无盘工作站在初始化自身的时候初始化子网掩码</li><li>时间戳查询：同步时间<h4 id="ICMP应用—ping"><a href="#ICMP应用—ping" class="headerlink" title="ICMP应用—ping"></a>ICMP应用—ping</h4>ping是利用ICMP协议报来侦测另一个主机是否可达。<br>原理就是用类型码为0的ICMP发请求，收到请求的主机则用类型码为8的ICMP进行回应。ping程序用来计算间隔时间，并计算有多少个包被送达。<br><img src="http://ofa8x9gy9.bkt.clouddn.com/ICMP-ping.png" alt><br>ping给出来了传送的时间和TTL的数据。<br>ping还给我们一个看主机到目的主机陆游的机会。因为，ICMP的ping请求在经过路由器的时候，路由器会把自己的IP放到数据报中，而最后主机则会把这个ip列表复制到回应ICMP数据包发回给主机。但很重要的一点IP头所能记录的信息是非常有限。  这样就有了另一个充分利用TTL数据的应用Traceroute  <h4 id="ICMP应用—Traceroute"><a href="#ICMP应用—Traceroute" class="headerlink" title="ICMP应用—Traceroute"></a>ICMP应用—Traceroute</h4>Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。<br>Traceroute基本原理原理：它收到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据报，而经过第一个的路由器收到数据报后，就会把TTL减1，这样TTL就会变为0.路由器就会抛弃数据报，并向主机发送目的主机不可达的ICMP数据报。然后主机就会发送TTL=2的数据报，如此往复直到到达目的主机。这样Traceroute就拿到了所有经过的路由器的IP。  <h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><h4 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h4>UDP是一个简单的面向数据报的传输层协议,UDP为网络层以上和应用层以下提供了一个简单的接口,传输方式”Best Effort”。UDP不用建立链接,它一旦把应用程序发给网络层的数据发送出去,就不保留备份。所以也就不提供超时重传，出错重传等功能。属于不可靠的协议。<br>UDP其实可以看做IP协议暴露在传输层的一个接口。传输层和网络层的区别在于:传输层是提供端到端的服务的。打个比方:小明(进程A)在M市要去寄一封信给在N市的小芳(进程B)，其中邮局就统一把很多的信，用车从M运到N市(网络层)。最后由邮递员(传输层)进行最后一步把小明的信送到小芳的家中。UDP可以看做IP协议在传输层的“傀儡”。<br>UDP的数据包分为头部和数据。UDP的数据报需要经过IP协议的封装，然后通过IP协议传输到目的电脑，随后拆封，并将信息送到相应端口的。<br><img src="http://ofa8x9gy9.bkt.clouddn.com/UDP%E7%9A%84%E5%B0%81%E8%A3%85.png" alt><br><img src="http://ofa8x9gy9.bkt.clouddn.com/UDP%E9%A6%96%E9%83%A8.png" alt>   <h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4>这在UDP中是一个可选的选项，UDP校验和覆盖UDP协议头和数据，这和IP的校验和是不同的，IP协议的校验和只是覆盖IP数据头。UDP和TCP都包含一个伪首部，伪首部包含IP地址，目的是让UDP两次检查数据是否已经正确到达目的地，如果发送端没有打开检验和选项，而接收端计算检验和有差错，那么UDP数据将会被悄悄的丢掉（不保证送达），而不产生任何差错报文。</li></ol>]]></content>
      
      
      <categories>
          
          <category> TCP/IP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICMP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java里的HashMap和golang里的map</title>
      <link href="/2016/12/05/Java%E9%87%8C%E7%9A%84hasMap%E5%92%8Cgolang%E9%87%8C%E7%9A%84map/"/>
      <url>/2016/12/05/Java%E9%87%8C%E7%9A%84hasMap%E5%92%8Cgolang%E9%87%8C%E7%9A%84map/</url>
      
        <content type="html"><![CDATA[<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表就是一种以<code>键-值(key-value)</code>存储数据的结构,我们只要输入待查找的键即Key,即可找到对应的值。<br>使用哈希找查有两个步骤:</p><ol><li>使用哈希函数将被找查的键转换为数组的索引.在理想的情况下,不同的键会被装换为不同的索引值,但是在有些情况下我们需要处理多个键被哈希到同一个索引值得情况。所以哈希查找的第二个步骤是处理冲突。</li><li>处理哈希碰撞冲突。一般处理哈希碰撞用拉链法和开放寻址法等方法。<blockquote><p>开放地址法:当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。<br>拉链法:当通过哈希函数把键转换为数组的索引时,如果索引重复,就在该位置用链表顺序 存储该键值对。  </p></blockquote></li></ol><p><img src="http://ofa8x9gy9.bkt.clouddn.com/%E6%8B%89%E9%93%BE%E6%B3%95.png" alt>  </p><h3 id="Java中的HashMap"><a href="#Java中的HashMap" class="headerlink" title="Java中的HashMap"></a>Java中的HashMap</h3><p>基本认识：基于Map接口,<em>允许null键/值,非同步,不保证有序</em>,也不保证顺序不随时间变化。<br>HashMap中和Map一样，键值对都是保存在一个内部类中的,而在HashMap类中有一个很重要的字段，那就是Node[] table，即是一个哈希桶数组。Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">       /.../</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a> <p>还有两个重要参数:  </p><ul><li>容量(Capacity)：Capacity就是bucket的大小</li><li>负载因子(Load factor)：Load factor就是bucket填满程度的最大比例。<br>如果对迭代性能要求很高的话不要把<code>capacity</code>设置过大,也不要吧<code>load factor</code>设置过小，当bucket的entries的数目大于<code>capacity*load factor</code>是就需要调整bucket的大小为当前的2倍。<h4 id="put-函数的基本思路"><a href="#put-函数的基本思路" class="headerlink" title="put()函数的基本思路:"></a><code>put()</code>函数的基本思路:</h4></li></ul><ol><li>对key的<code>hashCode()</code>做hash,然后计算对应的index</li><li>如果没有发生碰撞就直接放到桶里</li><li>如果发生碰撞就采用拉链法,以链表的形式存储在该桶里</li><li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD),就把链表转换为红黑树</li><li>如果节点存在,就替换成新的value</li><li>如果桶满了(超过load factor*current capacity),就要resize  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> putVal(hash(key),key,value,<span class="keyword">false</span>,<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash,K key,V value,<span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 计算index，并对null做处理</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 节点存在</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 该链为树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写入</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 超过load factor*current capacity，resize</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-函数的基本思路"><a href="#get-函数的基本思路" class="headerlink" title="get()函数的基本思路"></a><code>get()</code>函数的基本思路</h4><ol><li>桶里的第一个节点就直接命中</li><li>如果桶里有冲突，就通过<code>equal()</code>来找查对应的entry，若为树时间复杂度为O(logN)，链表就是O(N)   </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 直接命中</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="comment">// 未命中</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 在树中get</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="comment">// 在链表中get</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将<code>K/V</code>传给put方法时,它调用hashCode计算hash从而得到bucket位置,进一步存储，<code>HashMap</code>会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时,我们将K传给get,它调用hashCode计算hash从而得到bucket位置,并进一步调用equals()方法确定键值对。如果发生碰撞的时候，HashMap通过链表将产生碰撞冲突的元素组织起来,在Java 8中,如果一个bucket中碰撞冲突的元素超过某个限制(默认是8,则使用红黑树来替换链表,从而提高速度 </p><h3 id="golang中的map"><a href="#golang中的map" class="headerlink" title="golang中的map"></a>golang中的map</h3><p>基本认识:在go中一个map就是一个哈希表的引用,map类型可以写为map[K]V,对K的类型要求是必须支持<code>==</code>比较运算符。但是不建议使用浮点型作为Key。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Hmap&#123;<span class="comment">//map的关键数据</span></span><br><span class="line">    <span class="keyword">uint8</span>   B;    <span class="comment">// 可以容纳2^B个项</span></span><br><span class="line">    <span class="keyword">uint16</span>  bucketsize;   <span class="comment">// 每个桶的大小</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">byte</span>    *buckets;     <span class="comment">// 2^B个Buckets的数组</span></span><br><span class="line">    <span class="keyword">byte</span>    *oldbuckets;  <span class="comment">// 前一个buckets，只有当正在扩容时才不为空</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//初始化的3种方式</span></span><br><span class="line">ages:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)<span class="comment">// mapping from strings to ints</span></span><br><span class="line">ages:=<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">ages:=<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">"alice"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="string">"charlie"</span>:<span class="number">33</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取值</span></span><br><span class="line">ages[<span class="string">"alice"</span>]=<span class="number">0</span></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">ages[<span class="string">"charlie"</span>]=<span class="number">34</span></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="built_in">delete</span>(ages, <span class="string">"alice"</span>) <span class="comment">// remove element ages["alice"]</span></span><br></pre></td></tr></table></figure><p>上面这些都是安全的，及时失败也会返回对应value类型的零值。<br>但是有时候需要想知道对应的元素是否真的在map之中。推荐写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map的下标语法将产生两个值；第二个是一个布尔值   </span></span><br><span class="line"><span class="comment">//用于报告元素是否真的存在。布尔变量一般命名为ok，特别适合马上用于if条件判断部分。</span></span><br><span class="line"><span class="keyword">if</span> age, ok := ages[<span class="string">"alice"</span>]; !ok &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>在golang中主要采用增量扩容–扩容因子为<code>6.5</code>。这个主要是为了缩短map容器的响应时间，因为在map桶里面数据很多事,直接复制进行扩容就会很卡，导致较长一段时间无法响应请求。不过具体时间复杂度还是采用的均摊法。具体做法:</p><blockquote><p>扩容会建立一个大小是原来2倍的空表。将旧的bucket搬到新表中(复制),但是并不会将旧的bucket从oldbucket中删除，而是加上一个已删除的标记。</p></blockquote><p>由于整个过程是逐渐完成的,这样就会导致一部分数据还没有完全复制到新表，所以会对insert，remove，get等操作产生影响。并且只有当所有复制操作完成后才会释放oldbucket。  </p><h4 id="insert分析基本思路"><a href="#insert分析基本思路" class="headerlink" title="insert分析基本思路"></a><code>insert</code>分析基本思路</h4><ol><li>根据key算出hash值，进而得出索引的位置</li><li>如果bucket的位置在old table中，就重新hash到新表中</li><li>查找对应的位置，如果在bucket中如果已经存在相应的key，就覆盖原来value，没有就插入</li><li>根据table中元素的个数，判断是否扩容</li><li>如果对应的bucket已经full，重新申请新的bucket作为overbucket(溢出桶链表)。</li><li>将key/value pair插入到bucket中。  </li></ol><h4 id="get查找过程"><a href="#get查找过程" class="headerlink" title="get查找过程"></a><code>get</code>查找过程</h4><ol><li>根据key算出hash值，进而得出索引的位置</li><li>如果存在old table, 首先在old table中查找，如果找到的bucket已经扩容，转到步骤3。 反之，返回其对应的value。</li><li>在new table中查找对应的value。  </li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">do &#123; <span class="comment">//对每个bucket</span></span><br><span class="line">    <span class="comment">//依次比较桶内的每一项存放的高位hash与所求的hash值高位是否相等</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>, k = b-&gt;data, v = k + h-&gt;keysize * BUCKETSIZE; i &lt; BUCKETSIZE; i++, k += h-&gt;keysize, v += h-&gt;valuesize) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;tophash[i] == top) &#123; </span><br><span class="line">            k2 = IK(h, k);</span><br><span class="line">            t-&gt;key-&gt;alg-&gt;equal(&amp;eq, t-&gt;key-&gt;size, key, k2);</span><br><span class="line">            <span class="keyword">if</span>(eq) &#123; <span class="comment">//相等的情况下再去做key比较...</span></span><br><span class="line">                *keyp = k2;</span><br><span class="line">                <span class="keyword">return</span> IV(h, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b = b-&gt;overflow; <span class="comment">//b设置为它的下一下溢出链</span></span><br><span class="line">&#125; while(b != <span class="literal">nil</span>);</span><br></pre></td></tr></table></figure><p>这里一个细节需要注意一下。不认真看可能会以为低位用于定位bucket在数组的index，那么高位就是用于key/valule在bucket内部的offset。事实上高8位不是用作offset的，而是用于加快key的比较的。  </p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在扩容过程中，oldbucket是被冻结的，查找时会在oldbucket中查找，但不会在oldbucket中插入数据。如果在oldbucket是找到了相应的key，做法是将它迁移到新bucket后加入扩容标记。<br>然后就是只要在某个bucket中找到第一个空位，就会将key/value插入到这个位置。也就是位置位于bucket前面的会覆盖后面的(类似于存储系统设计中做删除时的常用的技巧之一，直接用新数据追加方式写，新版本数据覆盖老版本数据)。找到了相同的key或者找到第一个空位就可以结束遍历了。不过这也意味着做删除时必须完全的遍历bucket所有溢出链，将所有的相同key数据都删除。所以目前map的设计是为插入而优化的，删除效率会比插入低一些。  </p><hr><p>参考:<br><a href="http://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a><br><a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">Java HashMap工作原理及实现</a></p>]]></content>
      
      
      <categories>
          
          <category> Java和golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang的切片和Java的动态数组</title>
      <link href="/2016/11/29/golang%E7%9A%84%E5%88%87%E7%89%87%E5%92%8CJava%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/"/>
      <url>/2016/11/29/golang%E7%9A%84%E5%88%87%E7%89%87%E5%92%8CJava%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="Java里的动态数组—ArrayList"><a href="#Java里的动态数组—ArrayList" class="headerlink" title="Java里的动态数组—ArrayList"></a>Java里的动态数组—ArrayList</h3><p>ArrayList是实现List接口的动态数组，每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。随着向ArrayList中不断添加元素，容量会自动增长，自动增长会带来数据向新数组的<em>重新拷贝</em>。同时需要注意的是这个实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。(结构上的修改是指任何添加或删除一个或多个元素的的操作，或者显示调整底层数组的大小；仅仅设置元素的值不是结构上的修改)<br><a id="more"></a></p><h4 id="Java里面的初始化和实现"><a href="#Java里面的初始化和实现" class="headerlink" title="Java里面的初始化和实现"></a>Java里面的初始化和实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;   <span class="keyword">extends</span>  <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;  <span class="keyword">implements</span>   <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//设置arrayList默认容量</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//空数组，当调用无参数构造函数的时候默认给个空数组</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//这才是真正保存数据的数组</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//arrayList的实际元素数量</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//构造方法传入默认的capacity 设置默认数组大小</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">super</span>();</span><br><span class="line">         <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line">         <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//无参数构造方法默认为空数组</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">super</span>();</span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//构造方法传入一个Collection， 则将Collection里面的值copy到arrayList</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">         elementData = c.toArray();</span><br><span class="line">         size = elementData.length;</span><br><span class="line">         <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的源码可以看出来，ArrayList的本质就是数组的，其中的add,get,set,remove等操作都是对数组的操作，所以ArrayList的特性基本都是源于数组:有序、元素可以重复、插入慢、获取快等特性。</p><h4 id="ArrayList里面的将数组动态扩容实现add和remove"><a href="#ArrayList里面的将数组动态扩容实现add和remove" class="headerlink" title="ArrayList里面的将数组动态扩容实现add和remove"></a>ArrayList里面的将数组动态扩容实现add和remove</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//在末尾增加元素，虽然有时需要扩容但是时间复杂度为O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在数组中间增加元素，因为需要移动后面的元素，所以时间复杂度为O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">             minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">         modCount++;</span><br><span class="line">        <span class="comment">//超出了数组可容纳的长度，需要进行动态扩展</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//这才是动态扩展的核心</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">//设置新数组的容量扩展为原来数组的1.5倍</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组， 不够就将数组长度设置为需要的长度</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//判断有没超过最大限制</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">//将原来数组的值copy新数组中去</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面的ArrayList的源码就可以知道,整个ArrayList的动态实现就是在增加数据的时候判断数组的容量是否足够,不够就重新生成一个1.5倍的数组,然后进行复制。这就是整个ArrayList的核心。</p><h3 id="golang里面的动态数组—slice"><a href="#golang里面的动态数组—slice" class="headerlink" title="golang里面的动态数组—slice"></a>golang里面的动态数组—slice</h3><h4 id="Go中的数组定义"><a href="#Go中的数组定义" class="headerlink" title="Go中的数组定义"></a>Go中的数组定义</h4><p>在Go中的数组和Java有点不一样。在golang中数组是内置类型,初始化后长度是固定的，没有办法修改其长度,数组的长度也是其类型的一部分。数组是值类型,通过从0开始的下标索引访问元素值。值得注意的是如果GO中的数组作为函数的参数，那么实际传递的参数是一份数组的拷贝,而不是数组的指针。<br><img src="http://ofa8x9gy9.bkt.clouddn.com/golang%E6%95%B0%E7%BB%84.png" alt>  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b [<span class="number">5</span>]<span class="keyword">int</span> <span class="comment">//没有初始值，会自动的给出默认值&#123;0,0,0,0,0&#125;</span></span><br><span class="line">a:=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">b:=[...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><p>数组的长度是不可改变的,在很多场景都不是很适用，但是slice不一样。slice是golang的内置类型。在slice中有两个概念,和数组一样，有两个内置的属性：一个是len长度，一个是cap容量。slice是应用类型,因此当传递切片将和应用同一指针，修改值会影响其他的对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般建议的初始化是用make()来初始化</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>上面就可以表示一个slice,和声明数组差不多。只是少了一个长度。<br>slice也可以从一个数组或者已经存在的<code>slice</code>中再次声明。<code>slice</code>通过<code>a[i:j]</code>来获取,其中i是数组的开始位置,j是结束位置(不包含),长度为j-i </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个含有10个元素元素类型为byte的数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>]<span class="keyword">byte</span> &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明两个含有byte的slice</span></span><br><span class="line"><span class="keyword">var</span> a, b ,c ,d[]<span class="keyword">byte</span></span><br><span class="line"><span class="comment">// a指向数组的第3个元素开始，并到第五个元素结束，现在a含有的元素: arr[2]、arr[3]和ar[4]</span></span><br><span class="line">a = arr[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">// b是数组arr的另一个slice, b的元素是：arr[3]和arr[4]</span></span><br><span class="line">b = arr[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">//c是数组arr的另一个slice,c的元素师:arr[0],arr[1],arr[2]</span></span><br><span class="line">c = arr [:<span class="number">3</span>]</span><br><span class="line"><span class="comment">//slice的默认开始位置是0，arr[:n]等价于arr[0:n]</span></span><br><span class="line"><span class="comment">//slice的第二个序列默认是数组的长度，ar[n:]等价于ar[n:len(ar)]</span></span><br><span class="line"><span class="comment">//如果从一个数组里面直接获取slice，可以这样ar[:],因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)]</span></span><br></pre></td></tr></table></figure><p>基本结构如下：<br><img src="http://ofa8x9gy9.bkt.clouddn.com/slice.png" alt><br><code>slice</code>是引用类型,所以修改a中元素中的值，那么b中的值也会改变。<br>对于slice有几个有用的内置函数：</p><ul><li><code>len()</code>获取slice的长度</li><li><code>cap()</code>获取slice的最大容量</li><li><code>append()</code> 向slice中追加一个或者多个元素，然后返回一个和slice一样类型的slice</li><li><code>copy()</code> 从源slice的src中复制元素到目标dst，并且返回复制的元素的个数<br>slice一般都是通过<code>make()</code>进行实例化操作,在进行扩容是用<code>append()</code>,如果直接加入的个数打入slice的初始容量会报错。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本用法</span></span><br><span class="line">slice := <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="comment">//合并两个slice</span></span><br><span class="line">slice := <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,[]<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;...)</span><br><span class="line"><span class="comment">//将字符串当作[]byte类型作为第二个参数传入</span></span><br><span class="line">bytes := <span class="built_in">append</span>([]<span class="keyword">byte</span>(<span class="string">"hello"</span>),<span class="string">"world"</span>...)</span><br></pre></td></tr></table></figure><p>需要注意的是<code>append()</code>函数会改变slice的引用。cap不足时会按照cap的两倍进行扩容。</p><h3 id="有意思的算法—扩容"><a href="#有意思的算法—扩容" class="headerlink" title="有意思的算法—扩容"></a>有意思的算法—扩容</h3><p>首先有一个问题:在ArrayList中扩容是通过复制整个数组完成,每次当数组的容量满了，就会重新建一个长度是上次两倍的数组，然后进行复制操作，然后释放掉原来的数组。时间复杂度可以简单的看作使用for循环的嵌套，在复制数组的时候相当于用for循环来遍历了一遍数组。所以复制的时间复杂度应该是O(N)的。<br>但是整个ArrayList在末尾插入的时候表现是很快的。这里就有一个均摊的思想。  </p><ul><li>首先并不是每个元素的插入都会触发复制扩容这个操作。只有才数组长度不够的情况下，才会产生。然后均摊下来就是o(1)了。所以在某些情况下AarryList的性能会出现波动也是这个原因。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java和golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP初识</title>
      <link href="/2016/11/28/IP%E5%88%9D%E8%AF%86/"/>
      <url>/2016/11/28/IP%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h3><p>&emsp;最近一次接触ip是在我读《TCP/IP详解》时读到了，其实我感觉这些基础对理解整个互联网的结构都有一些很好的认识，在TCP/IP的协议簇中，首先简单的说一下在TCP中分层：  </p><ul><li>数据链路层:一般都是物理设备驱动程序和接口</li><li>网络层:处理分组在网络中的活动，如分组选路。TCP/IP中,IP协议,ICMP协议,IGMP协议</li><li>运输层:主要为应用程序提供端到端的通信，主要包括两种协议:TCP(高可靠的)、UDP(不可靠的，效率高的)</li><li>应用层:负责处理特定的应用程序的细节<br><img src="http://ofa8x9gy9.bkt.clouddn.com/TCP:IP%E5%88%86%E5%B1%82.png" alt><br>上图是我认为对TCP/IP分层的理解很好的一张图TCP/IP分层和传统的OSI分层不一样。OSI的7层是分的更加详细。对于TCP/IP的协议簇重点关注的还是网络层，运输层。  <a id="more"></a>  在TCP/IP中有一个分层的概念值得注意:  <blockquote><p>应用层关心的是应用程序的细节，而不是数据在网络中的传输活动。下三层对应用程序一无所知，但它们要处理所有的通信细节.IP协议是一种不可靠的网络层服务,它只是尽可能的快地把分组从源节点送到目的节点,并不提供任何可靠性的保证,但是IP得可靠服务可以由上层协议(TCP)来提供。</p></blockquote></li></ul><h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h3><p> &emsp;互联网上每个接口必须有一个唯一32位的Internet地址(IP地址),基本分类如下：<br><img src="http://ofa8x9gy9.bkt.clouddn.com/%E4%BA%94%E7%B1%BB%E4%BA%92%E8%81%94%E7%BD%91%E5%9C%B0%E5%9D%80.png" alt><br>IP地址是具有一定基本结构，一共有5类地址,每一类都包括:标志位、网络号、主机号。5类地址分为三种:单播地址(目的为单个主机,有:A、B、C)，广播地址(目的端为给定网络上的所有主机:D),多播地址(目的端为同一组内的所有主机:E)。  </p><h3 id="IP路由选择"><a href="#IP路由选择" class="headerlink" title="IP路由选择"></a>IP路由选择</h3><p>&emsp;在一般的通信中，IP可以从TCP、UDP、ICMP、接受数据报(即本地生成的数据报)并进行发送，或者从一个网络接口接受数据报并进行转发。IP层在内存中有一个路由表。当收到一份数据报并进行发送时，它都要对该表搜索一次。当数据报来自某个网络接口时，IP首先检查目的IP地址是否为本机的IP地址之一或者IP广播地址。如果确实是这样，数据报就被送到处理。如果数据报的目的不是这些地址，那么如果IP层被设置为路由器的功能，那么就对数据报进行转发，否则数据报就被丢弃。并且IP数据包的TTL(生命周期)为0，则该IP数据包就也会被抛弃。路由表中一般包含：目的IP地址，数据报传输的网络接口，下一跳的IP地址。<br>&emsp;IP路由选择是逐跳进行的。IP不知道到达任何目地的完整路径(除了与主机 直接相连的目的地)。所有的IP路由选择只为数据报传输提供下一站路由器的IP地址。它假定下一站路由器比发送数据报的主机更接近目的路由。如果IP数据报不能送达且来自本机那么一般会想生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误。<br>基本过程:</p><ol><li>如果ip数据包的TTL为0,则该IP数据报直接被丢弃</li><li>搜索路由表，优先搜索匹配主机，如果能找到和IP地址完全一致的目标主机,则将该包发向目标主机</li><li>搜索路由表，如果匹配主机失败，则匹配同子网的路由器，如果找到，则将该包发向路由器</li><li>搜索路由表，如果匹配同子网路由器失败，内匹配同网号路由器，如果找到，则将该包发向路由器</li><li>搜索路由表，如果以上都失败了，就搜索默认路由</li><li>如果都失败了，就直接丢弃<h3 id="子网寻址"><a href="#子网寻址" class="headerlink" title="子网寻址"></a>子网寻址</h3>&emsp;现在的所有主机都要求支持子网编址。不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是<em>把主机号在分成一个子网号和一个主机号</em>。这样做的原因就是应为A类和B类地址为主机号分配了太多的空间，可分别容纳的主机数为16777214和65534个主机,但是事实上,在一个网络中一般安排不了这么多的主机。下图为B类子网划分的例子:<br><img src="http://ofa8x9gy9.bkt.clouddn.com/%E5%AD%90%E7%BD%91%E5%AF%BB%E5%9D%80.png" alt><br>上面是一个B类网络地址(140.252),在剩下的16位中，8为用于子网号,8为用于主机号,这样就允许254个子网,每个子网就可以有254台主机。  <h3 id="IP的子网掩码"><a href="#IP的子网掩码" class="headerlink" title="IP的子网掩码"></a>IP的子网掩码</h3>&emsp;由于除了IP地址外，主机还需要知道有那几位是子网号,那几位是主机号,这两个信息都是通过子网掩码来获得<br><img src="http://ofa8x9gy9.bkt.clouddn.com/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.png" alt>  <blockquote><p>ps:判断一个IP地址所属的类别，一般看IP地址的开头就行，不看子网掩码。一般0~127是A类,128~191是B类,192~223是C类，224~239是D类。  </p></blockquote></li></ol><h3 id="ARP协议—地址解析协议"><a href="#ARP协议—地址解析协议" class="headerlink" title="ARP协议—地址解析协议"></a>ARP协议—地址解析协议</h3><p>&emsp;首先在以太网协议中的规定，同一局域网的一台主机要和另一台主机进行通信，必须知道目标主机的MAC地址。但是在TCP/IP协议中，网络层和传输层都只关心目标主机的IP地址.所以这个ARP协议就是IP和MAC的一种映射。<br>具体过程:当A:192.168.10.11向B：192.168.10.19发送数据时，主机A首先会在自己的ARP缓存表(IP-MAC地址的对应表)中寻找是否有目标的MAC，如果不存在，那么主机就向同一网段的网络发送一个ARP协议的广播包(谁知道192.168.10.19的MAC地址)，网络上其他主机并不会响应ARP的广播，只有主机B接受大这个广播才会向主机A做出回应。主机A就知道主机B的MAC地址，它就可以向主机B发送信息。同时它还更新自己的ARP缓存表，下次再向主机B发送信息时，直接从ARP缓存表里查找就可。同时ARP缓存表采用老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可以大大减少ARP缓存表的长度，加快查询速度。  </p>]]></content>
      
      
      <categories>
          
          <category> TCP/IP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2016/11/25/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2016/11/25/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="开始写了有点小激动"><a href="#开始写了有点小激动" class="headerlink" title="开始写了有点小激动"></a>开始写了有点小激动</h3><p>&emsp;&emsp;第一篇博客，其实以前也写过一些博文，但是都是不成体系的，一直都想写，但是总被一些事情给牵住了，终于可以开始第一篇博文的书写。这个博客主要记录我从大四实习开始的路程，不知道以后这个博客可以坚持多长时间，但是希望越久越好。我现在主要方向还是Java和golang的后端开发。因为两个的基础都不是很好。积累基础是一个很缓慢的过程，所以只能慢慢的往上爬。不能急。我会在博客中更新我最近学习的东西，和在工作中的坑。希望自己的技术能越来越来。说不定，以后就给自己的博客一个独立的域名，只是现在，刚开始。不急。</p>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> start </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
